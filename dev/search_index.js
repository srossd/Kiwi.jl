var documenterSearchIndex = {"docs":
[{"location":"api/tensor_products/#Tensor-Products-API","page":"Tensor Products","title":"Tensor Products API","text":"","category":"section"},{"location":"api/tensor_products/#Computing-Tensor-Products","page":"Tensor Products","title":"Computing Tensor Products","text":"","category":"section"},{"location":"api/tensor_products/#Plethysms","page":"Tensor Products","title":"Plethysms","text":"","category":"section"},{"location":"api/tensor_products/#Unicode-Operator","page":"Tensor Products","title":"Unicode Operator","text":"rep1 ⊗ rep2  # Same as tensor_product(rep1, rep2)\n\nType \\otimes<TAB> in Julia REPL to get ⊗.","category":"section"},{"location":"api/tensor_products/#Kiwi.tensor_product-Tuple{Irrep, Irrep}","page":"Tensor Products","title":"Kiwi.tensor_product","text":"tensor_product(rep1::Irrep, rep2::Irrep)\n\nCompute the tensor product of two irreducible representations using Klimyk's formula.\n\nKlimyk's formula (also known as the Racah-Speiser algorithm) states that:\n\nrep1 ⊗ rep2 = Σ_μ Σ_{w ∈ W} sign(w) · [w(λ₁ + μ)]\n\nwhere:\n\nλ₁ is the highest weight of rep1 (we choose rep1 to be the smaller-dimensional one)\nThe first sum is over all weights μ in the character of rep2\nW is the Weyl group\n[w(λ₁ + μ)] means: reflect w(λ₁ + μ) to the dominant chamber and interpret as an irrep\nsign(w) is the determinant of the Weyl group element w\n\nThe formula automatically handles the necessary cancellations, and only dominant  weights contribute to the final result.\n\nReferences\n\nKlimyk, \"Decomposition of the direct product of irreducible representations\" (1968)\nRacah, \"Group Theory and Spectroscopy\" (1965)\n\nExample\n\ng = A_series(2)\nfund1 = Irrep(g, 1, 0)\nfund2 = Irrep(g, 0, 1)\nresult = tensor_product(fund1, fund2)\n\n\n\n\n\n","category":"method"},{"location":"api/tensor_products/#Kiwi.tensor_product-Tuple{Irrep, Rep}","page":"Tensor Products","title":"Kiwi.tensor_product","text":"tensor_product(rep1::Irrep, rep2::Rep)\ntensor_product(rep1::Rep, rep2::Irrep)\n\nTensor product between irreducible and reducible representations.\n\n\n\n\n\n","category":"method"},{"location":"api/tensor_products/#Kiwi.tensor_product-Tuple{Rep, Rep}","page":"Tensor Products","title":"Kiwi.tensor_product","text":"tensor_product(rep1::Rep, rep2::Rep)\n\nCompute the tensor product of two (possibly reducible) representations.\n\nUses bilinearity: (⊕ᵢ nᵢRᵢ) ⊗ (⊕ⱼ mⱼSⱼ) = ⊕ᵢⱼ (nᵢmⱼ)(Rᵢ ⊗ Sⱼ)\n\n\n\n\n\n","category":"method"},{"location":"api/tensor_products/#Kiwi.antisymmetric_power-Tuple{Int64, Irrep}","page":"Tensor Products","title":"Kiwi.antisymmetric_power","text":"antisymmetric_power(n::Int, irrep::Irrep)\n\nCompute the n-th antisymmetric (exterior) power of an irreducible representation.\n\nThis is a convenience function that computes the plethysm with the alternating representation of Sₙ.\n\nArguments\n\nn: The power (positive integer)\nirrep: The irreducible representation\n\nReturns\n\nA Rep object representing the decomposition into irreps.\n\nExample\n\ng = SU(3)\nfund = Irrep(g, [1, 0])\nalt2 = antisymmetric_power(2, fund)  # Λ²(3) = [0,1]\n\n\n\n\n\n","category":"method"},{"location":"api/tensor_products/#Kiwi.plethysm-Tuple{Irrep, SymmetricIrrep}","page":"Tensor Products","title":"Kiwi.plethysm","text":"plethysm(lambda::Irrep, rho::SymmetricIrrep)\n\nCompute the plethysm of a Lie algebra irrep λ with a symmetric group irrep ρ.\n\nThis computes the character of the composition λ[ρ], which describes how the  representation λ transforms under the symmetric group action.\n\nAlgorithm\n\nFor each conjugacy class of S_n with partition (p₁, ..., pₖ):\n\nCompute adams(pᵢ, λ) for each part pᵢ\nTake the tensor product of all these (treating as reducible representations)\nWeight by (conjugacy class size) × character(ρ, class) / n!\nSum over all conjugacy classes\n\nArguments\n\nlambda: The Lie algebra irreducible representation\nrho: The symmetric group irreducible representation\n\nReturns\n\nA Rep object representing the decomposition into Lie algebra irreps.\n\nExample\n\ng = A_series(2)\nlambda = Irrep(g, [1, 0])  # Fundamental rep of SU(3)\nrho = SymmetricIrrep([2])   # Symmetric square representation of S_2\nresult = plethysm(lambda, rho)\n\n\n\n\n\n","category":"method"},{"location":"api/tensor_products/#Kiwi.symmetric_power-Tuple{Int64, Irrep}","page":"Tensor Products","title":"Kiwi.symmetric_power","text":"symmetric_power(n::Int, irrep::Irrep)\n\nCompute the n-th symmetric power of an irreducible representation.\n\nThis is a convenience function that computes the plethysm with the trivial (all-symmetric) representation of Sₙ.\n\nArguments\n\nn: The power (positive integer)\nirrep: The irreducible representation\n\nReturns\n\nA Rep object representing the decomposition into irreps.\n\nExample\n\ng = SU(3)\nfund = Irrep(g, [1, 0])\nsym2 = symmetric_power(2, fund)  # S²(3) = [2,0]\n\n\n\n\n\n","category":"method"},{"location":"guide/tensor_products/#Tensor-Products","page":"Tensor Products","title":"Tensor Products","text":"Compute the decomposition of tensor products of representations into irreducible components using the ⊗ operator.","category":"section"},{"location":"guide/tensor_products/#Basic-Examples","page":"Tensor Products","title":"Basic Examples","text":"Let's use SU(3) to see how tensor products work:\n\nusing Kiwi\n\n# SU(3) = A_2\nsu3 = SU(3)\n\n# Define the fundamental representations\nfund = Irrep(su3, [1, 0])       # 3\nanti_fund = Irrep(su3, [0, 1])  # 3̄\nadj = Irrep(su3, [1, 1])        # 8\nnothing # hide","category":"section"},{"location":"guide/tensor_products/#Fundamental-Fundamental","page":"Tensor Products","title":"Fundamental × Fundamental","text":"# 3 ⊗ 3 = 3̄ ⊕ 6\nresult = fund ⊗ fund\nprintln(\"[1,0] ⊗ [1,0] = \", result)\nprintln(\"Dimension of result: \", dimension(result))","category":"section"},{"location":"guide/tensor_products/#Adjoint-Adjoint","page":"Tensor Products","title":"Adjoint × Adjoint","text":"# 8 ⊗ 8 = 1 ⊕ 8 ⊕ 8 ⊕ 10 ⊕ 10̄ ⊕ 27\nresult = adj ⊗ adj\nprintln(\"[1,1] ⊗ [1,1] = \", result)\nprintln(\"Dimension of result: \", dimension(result))","category":"section"},{"location":"guide/tensor_products/#Accessing-Components","page":"Tensor Products","title":"Accessing Components","text":"# Get multiplicity of a specific irrep in 3 ⊗ 3̄\nresult = fund ⊗ anti_fund\ntrivial = Irrep(su3, [0, 0])\nresult[trivial]  # 1","category":"section"},{"location":"guide/tensor_products/#Plethysms","page":"Tensor Products","title":"Plethysms","text":"Plethysms compute symmetric and antisymmetric powers of representations. Use the symmetric_power and antisymmetric_power helper functions, or the general plethysm function with symmetric group irreps.","category":"section"},{"location":"guide/tensor_products/#Symmetric-Powers","page":"Tensor Products","title":"Symmetric Powers","text":"# S²([1,0]) - symmetric square of the fundamental\nresult = symmetric_power(2, fund)\nprintln(\"S²([1,0]) = \", result)\nprintln(\"Dimension: \", dimension(result))  # 6","category":"section"},{"location":"guide/tensor_products/#Antisymmetric-Powers","page":"Tensor Products","title":"Antisymmetric Powers","text":"# Λ²([1,0]) - antisymmetric square of the fundamental\nresult = antisymmetric_power(2, fund)\nprintln(\"Λ²([1,0]) = \", result)\nprintln(\"Dimension: \", dimension(result))  # 3","category":"section"},{"location":"guide/tensor_products/#Higher-Powers","page":"Tensor Products","title":"Higher Powers","text":"# S³([1,1]) - symmetric cube of the adjoint\nresult = symmetric_power(3, adj)\nprintln(\"S³([1,1]) = \", result)\nprintln(\"Total dimension: \", dimension(result))  # 120","category":"section"},{"location":"guide/tensor_products/#General-Plethysms","page":"Tensor Products","title":"General Plethysms","text":"For more general plethysms, use the plethysm function with symmetric group representations:\n\n# Mixed symmetry: [2,1] representation of S₃\nrho = SymmetricIrrep([2, 1])\nresult = plethysm(fund, rho)\nprintln(\"[2,1]([1,0]) = \", result)","category":"section"},{"location":"guide/tensor_products/#See-Also","page":"Tensor Products","title":"See Also","text":"API Reference: Tensor Products","category":"section"},{"location":"api/algebras/#Lie-Algebras-API","page":"Lie Algebras","title":"Lie Algebras API","text":"","category":"section"},{"location":"api/algebras/#Creating-Algebras","page":"Lie Algebras","title":"Creating Algebras","text":"","category":"section"},{"location":"api/algebras/#Algebra-Properties","page":"Lie Algebras","title":"Algebra Properties","text":"","category":"section"},{"location":"api/algebras/#Root-System","page":"Lie Algebras","title":"Root System","text":"","category":"section"},{"location":"api/algebras/#Kiwi.A_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.A_series","text":"A_series(n::Int)\n\nConstruct the A_n Lie algebra (su(n+1)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.B_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.B_series","text":"B_series(n::Int)\n\nConstruct the B_n Lie algebra (so(2n+1)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.C_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.C_series","text":"C_series(n::Int)\n\nConstruct the C_n Lie algebra (sp(2n)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.D_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.D_series","text":"D_series(n::Int)\n\nConstruct the D_n Lie algebra (so(2n)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.E_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.E_series","text":"E_series(n::Int)\n\nConstruct the E_n Lie algebra (n = 6, 7, or 8).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.F_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.F_series","text":"F_series(n::Int)\n\nConstruct the F_4 Lie algebra (n must be 4).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.G_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.G_series","text":"G_series(n::Int)\n\nConstruct the G_2 Lie algebra (n must be 2).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.cartan_matrix-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.cartan_matrix","text":"cartan_matrix(g::LieAlgebra)\n\nReturn the Cartan matrix for the given Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.dual_coxeter_number-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.dual_coxeter_number","text":"dual_coxeter_number(g::LieAlgebra)\n\nCompute the dual Coxeter number hⱽ of the Lie algebra. This is defined as the Dynkin index of the adjoint representation.\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.lie_rank-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.lie_rank","text":"lie_rank(g::LieAlgebra)\n\nReturn the rank of the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.simple_roots-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.simple_roots","text":"simple_roots(g::LieAlgebra)\n\nReturn the simple roots of the Lie algebra in the fundamental weight basis. The simple root αi in fundamental weight coordinates: αi = Σj Cij ω_j (rows of C)\n\n\n\n\n\n","category":"method"},{"location":"guide/characters/#Characters","page":"Characters","title":"Characters","text":"Characters provide the complete weight decomposition of a representation, giving all weights with their multiplicities.","category":"section"},{"location":"guide/characters/#Computing-Characters","page":"Characters","title":"Computing Characters","text":"Let's start with some SU(3) examples:\n\nusing Kiwi\n\nsu3 = SU(3)\nfund = Irrep(su3, [1, 0])      # 3\nanti_fund = Irrep(su3, [0, 1])  # 3̄\nadj = Irrep(su3, [1, 1])       # 8\n\n# Compute characters\nchar_fund = character(fund)\nchar_anti = character(anti_fund)\nchar_adj = character(adj)\n\nCheck dimensions and number of distinct weights:\n\n[dimension(char_fund), length(char_fund)]  # [3, 3]\n\n[dimension(char_anti), length(char_anti)]  # [3, 3]\n\n[dimension(char_adj), length(char_adj)]    # [8, 7]","category":"section"},{"location":"guide/characters/#Accessing-Weight-Multiplicities","page":"Characters","title":"Accessing Weight Multiplicities","text":"# Query a specific weight in the adjoint\nw = Weight(su3, [0, 0])\nchar_adj[w]  # 2 (the zero weight has multiplicity 2 in the adjoint)","category":"section"},{"location":"guide/characters/#Lazy-Characters","page":"Characters","title":"Lazy Characters","text":"For large representations, we can set lazy=true to compute multiplicities on demand without computing the full character:\n\nusing Kiwi\n\n# Large E₆ representation: [1,0,1,1,0,1] has dimension 138,881,925\ne6 = E_series(6)\nrep = Irrep(e6, [2, 1, 0, 0, 0, 1])\n\nprintln(\"Dimension: \", dimension(rep))\n\n# Create lazy character (instant)\nlazy_char = character(rep; lazy=true)\n\nQuery specific weights quickly:\n\n# Highest weight\n@time lazy_char[highest_weight(rep)]\nlength(lazy_char.computed)\n@time lazy_char[Weight(e6, [-1, -2, 1, 1, -2, 1])]\nlength(lazy_char.computed)\n\nFor comparison, computing the full character takes much longer:\n\n@time char_full = character(rep);\n\nThe lazy character only computes what you need, making it efficient for querying specific multiplicities in large representations.","category":"section"},{"location":"guide/characters/#See-Also","page":"Characters","title":"See Also","text":"API Reference: Characters","category":"section"},{"location":"guide/lie_algebras/#Lie-Algebras","page":"Lie Algebras","title":"Lie Algebras","text":"Kiwi.jl provides comprehensive support for all simple Lie algebras.","category":"section"},{"location":"guide/lie_algebras/#Creating-Lie-Algebras","page":"Lie Algebras","title":"Creating Lie Algebras","text":"","category":"section"},{"location":"guide/lie_algebras/#Classical-Algebras","page":"Lie Algebras","title":"Classical Algebras","text":"You can create Lie algebras using either the series notation or standard mathematical notation:\n\nusing Kiwi # hide\n\n# A series: SU(n+1)\nsu3 = A_series(2)    # SU(3)\nsu5 = A_series(4)    # SU(5)\n\n# Or use the SU helper\nsu3_alt = SU(3)      # Same as A_series(2)\n\n# B series: SO(2n+1)\nso5 = B_series(2)    # SO(5)\nso9 = B_series(4)    # SO(9)\n\n# Or use the SO helper\nso5_alt = SO(5)      # Same as B_series(2)\n\n# C series: Sp(2n)\nsp4 = C_series(2)    # Sp(4)\nsp6 = C_series(3)    # Sp(6)\n\n# Or use the Sp helper\nsp4_alt = Sp(4)      # Same as C_series(2)\n\n# D series: SO(2n)\nso8 = D_series(4)    # SO(8)\nso10 = D_series(5)   # SO(10)\n\n# Or use the SO helper\nso8_alt = SO(8)      # Same as D_series(4)\nnothing # hide\n\nThe helper functions SU(n), SO(n), and Sp(n) provide more intuitive notation:\n\nSU(n) creates su(n), which is A_{n-1} (requires n ≥ 2)\nSO(n) creates so(n), which is Bk for n=2k+1 or Dk for n=2k (requires n ≥ 3)\nSp(n) creates sp(n), which is C_{n/2} (requires even n ≥ 2)","category":"section"},{"location":"guide/lie_algebras/#Exceptional-Algebras","page":"Lie Algebras","title":"Exceptional Algebras","text":"e6 = E_series(6)\ne7 = E_series(7)\ne8 = E_series(8)\nf4 = F_series(4)\ng2 = G_series(2)\nnothing # hide","category":"section"},{"location":"guide/lie_algebras/#Algebra-Properties","page":"Lie Algebras","title":"Algebra Properties","text":"","category":"section"},{"location":"guide/lie_algebras/#Basic-Properties","page":"Lie Algebras","title":"Basic Properties","text":"println(\"SU(3) properties:\")\nprintln(\"--------------\")\nprintln(\"Dimension: \", dimension(su3))\nprintln(\"Rank: \", lie_rank(su3))\nprintln(\"Dual Coxeter number: \", dual_coxeter_number(su3))\nprintln(\"Cartan matrix:\\n\", cartan_matrix(su3))","category":"section"},{"location":"guide/lie_algebras/#Root-System","page":"Lie Algebras","title":"Root System","text":"Access the simple roots:\n\nprintln(\"Simple roots of SU(3): \", simple_roots(su3))\n\nThe Weyl vector ρ (half-sum of positive roots):\n\nprintln(\"Weyl vector of SU(3): \", weyl_vector(su3))","category":"section"},{"location":"guide/lie_algebras/#See-Also","page":"Lie Algebras","title":"See Also","text":"API Reference: Lie Algebras: Complete function documentation","category":"section"},{"location":"guide/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Install Kiwi.jl using Julia's package manager:\n\nusing Pkg\nPkg.add(\"Kiwi\")","category":"section"},{"location":"guide/getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"using Kiwi\n\n# Create a Lie algebra\nSU3 = SU(3)\n\n# Get properties of representations\nfund = Irrep(SU3, 1, 0)\nprintln(\"Properties of fundamental representation:\")\nprintln(\"\\tDimension: \", dimension(fund))\nprintln(\"\\tCasimir:   \", quadratic_casimir(fund))\nprintln(\"\\tIndex:     \", dynkin_index(fund))","category":"section"},{"location":"guide/getting_started/#Key-Concepts","page":"Getting Started","title":"Key Concepts","text":"","category":"section"},{"location":"guide/getting_started/#Lie-Algebras","page":"Getting Started","title":"Lie Algebras","text":"Kiwi.jl supports all classical and exceptional simple Lie algebras:\n\nA series: SU(n+1)\nB series: SO(2n+1)\nC series: Sp(2n)\nD series: SO(2n)\nE series: E₆, E₇, E₈\nF series: F₄\nG series: G₂","category":"section"},{"location":"guide/getting_started/#Irreducible-Representations","page":"Getting Started","title":"Irreducible Representations","text":"Representations are specified by their highest weight in terms of Dynkin labels:\n\n# SU(3) representations\nanti_fund = Irrep(SU(3), 0, 1)   # 3̄\nadjoint = Irrep(SU(3), 1, 1)     # 8\n\n# SO(5) representations\nvector = Irrep(SO(5), 1, 0)      # 5\nspinor = Irrep(SO(5), 0, 1)      # 4\n\nprint([rep => dimension(rep) for rep in [fund, anti_fund, adjoint, vector, spinor]])","category":"section"},{"location":"guide/getting_started/#Characters","page":"Getting Started","title":"Characters","text":"The character of a representation is the complete list of weights with their multiplicities:\n\nprint(character(fund))","category":"section"},{"location":"guide/getting_started/#Tensor-Products","page":"Getting Started","title":"Tensor Products","text":"Compute tensor product decompositions using the ⊗ operator:\n\nprint(fund ⊗ anti_fund)","category":"section"},{"location":"guide/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Lie Algebras\nRepresentations\nTensor Products\nCharacters\nWeyl groups","category":"section"},{"location":"api/characters/#Characters-API","page":"Characters","title":"Characters API","text":"","category":"section"},{"location":"api/characters/#Computing-Characters","page":"Characters","title":"Computing Characters","text":"","category":"section"},{"location":"api/characters/#Kiwi.character-Tuple{Irrep}","page":"Characters","title":"Kiwi.character","text":"character(rep::Irrep; lazy=false)\n\nCompute the complete character of an irreducible representation. Returns a Character object containing all weights with their multiplicities.\n\nUses Freudenthal's multiplicity formula, which recursively computes the multiplicity of each weight μ from the multiplicities of weights μ + kα for positive roots α.\n\nArguments\n\nrep::Irrep: The irreducible representation\nlazy::Bool=false: If true, computes weights on demand.                     If false, all weights precomputed.\n\nAlgorithm\n\nStarting from the highest weight λ (with multiplicity 1), we work our way down by subtracting positive roots. For each new weight μ, Freudenthal's formula gives:\n\n2(λ+ρ, μ) m(μ) = Σ_{α>0} Σ_{k≥1} 2(μ+kα, α) m(μ+kα)\n\nwhere the sum is over all positive roots α and all k such that μ+kα is a weight.\n\nReturns\n\nA Character object.\n\nExamples\n\n# Eager evaluation (default): precomputes all weights\nrep = Irrep(SU(3), [1, 0])\nchar = character(rep)\n\n# Lazy evaluation: computes weights on demand\nchar_lazy = character(rep; lazy=true)\n\nReferences\n\nHumphreys, \"Introduction to Lie Algebras and Representation Theory\" (1972), §22.3\nFulton & Harris, \"Representation Theory\" (1991), §15.2\n\n\n\n\n\n","category":"method"},{"location":"api/characters/#Kiwi.dimension-Tuple{Character}","page":"Characters","title":"Kiwi.dimension","text":"dimension(char::Character)\n\nCompute the dimension of a character. For eager characters, sums all weight multiplicities. For lazy characters, uses the irrep's dimension formula.\n\n\n\n\n\n","category":"method"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Kiwi.LieAlgebra","page":"Types","title":"Kiwi.LieAlgebra","text":"LieAlgebra\n\nRepresents a simple Lie algebra by its type and rank. Supported types: A, B, C, D (classical) and E, F, G (exceptional).\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.CongruencyClass","page":"Types","title":"Kiwi.CongruencyClass","text":"CongruencyClass\n\nRepresents the congruency class (character of the center) of an irreducible representation. Different Lie algebras have different center structures:\n\nAn: Z{n+1}\nBn: Z2\nCn: Z2\nD{2n}: Z2 × Z_2\nD{2n+1}: Z4\nE6: Z3\nE7: Z2\nE8, F4, G_2: trivial\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Irrep","page":"Types","title":"Kiwi.Irrep","text":"Irrep\n\nRepresents an irreducible representation of a Lie algebra by its highest weight. The highest weight is specified by Dynkin labels.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Rep","page":"Types","title":"Kiwi.Rep","text":"Rep\n\nRepresents a (possibly reducible) representation as a linear combination of irreps. Stored as a dictionary mapping irreps to their multiplicities.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Weight","page":"Types","title":"Kiwi.Weight","text":"Weight vector in the weight space of a Lie algebra. Weights are represented as linear combinations of fundamental weights: w = Σ ci ωi.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Character","page":"Types","title":"Kiwi.Character","text":"Character\n\nRepresents a character of an irreducible representation. Can be eagerly computed (all weights precomputed) or lazy (weights computed on demand).\n\nFields\n\nalgebra::LieAlgebra: The Lie algebra\nirrep::Union{Irrep, Nothing}: The irrep (needed for lazy evaluation)\nweights::Dict{Weight, Int}: Computed weight multiplicities\nlazy::Bool: Whether to compute weights on demand\nρ::Union{Weight, Nothing}: Weyl vector (cached for lazy evaluation)\npositive_roots::Union{Vector{Weight}, Nothing}: Positive roots (cached for lazy evaluation)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.WeightMultiplicity","page":"Types","title":"Kiwi.WeightMultiplicity","text":"WeightMultiplicity\n\nA weight with its multiplicity in a representation.\n\n\n\n\n\n","category":"type"},{"location":"api/representations/#Representations-API","page":"Representations","title":"Representations API","text":"","category":"section"},{"location":"api/representations/#Creating-Representations","page":"Representations","title":"Creating Representations","text":"","category":"section"},{"location":"api/representations/#Finding-Representations","page":"Representations","title":"Finding Representations","text":"","category":"section"},{"location":"api/representations/#Representation-Properties","page":"Representations","title":"Representation Properties","text":"","category":"section"},{"location":"api/representations/#Kiwi.adjoint_irrep-Tuple{LieAlgebra}","page":"Representations","title":"Kiwi.adjoint_irrep","text":"adjoint_irrep(g::LieAlgebra)\n\nReturn the adjoint representation of the Lie algebra as an Irrep.\n\nThe adjoint representation corresponds to the Lie algebra acting on itself via the commutator. For any simple Lie algebra, the adjoint has highest weight equal to the highest root, which can be expressed in Dynkin labels.\n\nDynkin labels for adjoint representations\n\nA_n: 1, 0, ..., 0, 1\nB_n: 0, 1, 0, ..., 0\nC_n: 2, 0, ..., 0\nD_n: 0, 1, 0, ..., 0\nE_6: 0, 0, 0, 0, 0, 1\nE_7: 1, 0, 0, 0, 0, 0, 0\nE_8: 0, 0, 0, 0, 0, 0, 1, 0\nF_4: 1, 0, 0, 0\nG_2: 0, 1\n\nReferences\n\nFulton & Harris, \"Representation Theory\" (1991), Section 21.1\nHumphreys, \"Introduction to Lie Algebras and Representation Theory\" (1972)\nOnline database: http://www.liegroups.org/\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.clear_irreps_cache!-Tuple{}","page":"Representations","title":"Kiwi.clear_irreps_cache!","text":"clear_irreps_cache!()\n\nClear the cache for irrepsupto_dim.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.irreps_up_to_dim-Tuple{LieAlgebra, Int64}","page":"Representations","title":"Kiwi.irreps_up_to_dim","text":"irreps_up_to_dim(algebra::LieAlgebra, maxDim::Int; use_cache::Bool=true)\n\nReturn all irreducible representations of the given algebra with dimension up to maxDim.\n\nUses breadth-first search starting from the trivial representation, incrementing Dynkin labels one at a time until the dimension exceeds maxDim.\n\nResults are cached, so if a larger maxDim has been computed for the same algebra, the cached result will be filtered instead of recomputing from scratch.\n\nSet use_cache=false to disable caching and force recomputation.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.congruency_class-Tuple{Irrep}","page":"Representations","title":"Kiwi.congruency_class","text":"congruency_class(rep::Irrep)\n\nCompute the congruency class of an irreducible representation from its Dynkin labels.\n\nThe formulas for each algebra type are:\n\nAn: p1 + 2p2 + ... + n*pn (mod n+1)\nBn: pn (mod 2)\nCn: p1 + p3 + p5 + ... (mod 2)\nD{2n}: (p{2n-1} + p{2n}, p1 + p3 + ... + p{2n-3} + (n-1)p_{2n-1} + np_{2n}) (mod 2 for each)\nD{2n+1}: 2(p1 + p3 + ... + p{2n-1}) + (2n-1)p_{2n} + (2n+1)p_{2n+1} (mod 4)\nE6: p1 - p2 + p4 - p_5 (mod 3)\nE7: p4 + p6 + p7 (mod 2)\nE8, F4, G_2: trivial\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.conjugate-Tuple{Irrep}","page":"Representations","title":"Kiwi.conjugate","text":"conjugate(rep::Irrep)\n\nReturn the conjugate (dual) representation.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.dimension_label-Tuple{Irrep}","page":"Representations","title":"Kiwi.dimension_label","text":"dimension_label(rep::Irrep)\n\nReturn a string label for the representation combining dimension with distinguishing marks.\n\nThe label consists of:\n\nThe dimension\nA bar (̄) if the representation appears after its conjugate in the canonical ordering\nPrime marks (′) to distinguish between representations with the same dimension and conjugation\n\nFor SO(8) (D4), uses special triality labels: 8v (vector), 8s (spinor), 8c (conjugate spinor).\n\nThe canonical ordering is by: increasing Dynkin index, increasing congruency class value, then decreasing lexicographic order of Dynkin labels.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.dynkin_labels-Tuple{Irrep}","page":"Representations","title":"Kiwi.dynkin_labels","text":"dynkin_labels(rep::Irrep)\n\nGet the Dynkin labels of an irreducible representation.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.is_self_conjugate-Tuple{Irrep}","page":"Representations","title":"Kiwi.is_self_conjugate","text":"is_self_conjugate(rep::Irrep)\n\nCheck if the representation is self-conjugate.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.is_trivial-Tuple{Irrep}","page":"Representations","title":"Kiwi.is_trivial","text":"is_trivial(rep::Irrep)\n\nCheck if the representation is the trivial representation.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.dimension-Tuple{Irrep}","page":"Representations","title":"Kiwi.dimension","text":"dimension(rep::Irrep)\n\nCompute the dimension of an irreducible representation using Weyl's dimension formula: dim(λ) = ∏_{α > 0} (λ+ρ, α) / (ρ, α) where the product is over all positive roots α, and ρ is the Weyl vector.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.dynkin_index-Tuple{Irrep}","page":"Representations","title":"Kiwi.dynkin_index","text":"dynkin_index(rep::Irrep)\n\nCompute the Dynkin index (also known as the second index) of the representation. For the adjoint representation, this equals 2h^∨ (twice the dual Coxeter number).\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.quadratic_casimir-Tuple{Irrep}","page":"Representations","title":"Kiwi.quadratic_casimir","text":"quadratic_casimir(rep::Irrep)\n\nCompute the quadratic Casimir invariant C_2(rep). The eigenvalue is given by (λ, λ + 2ρ) / 2 where ρ is the Weyl vector. This normalization is standard in physics literature.\n\n\n\n\n\n","category":"method"},{"location":"guide/representations/#Representations","page":"Representations","title":"Representations","text":"Representations in Kiwi.jl are specified by their Dynkin labels, which correspond to the highest weight in the fundamental weight basis.","category":"section"},{"location":"guide/representations/#Defining-Representations","page":"Representations","title":"Defining Representations","text":"Let's use SO(6) as an example:\n\nusing Kiwi\n\n# SO(6) = D_3\nso6 = SO(6)\n\n# Define representations by Dynkin labels\nvector = Irrep(so6, [1, 0, 0])      # 6-dimensional vector\nspinor_plus = Irrep(so6, [0, 1, 0])  # 4-dimensional spinor\nspinor_minus = Irrep(so6, [0, 0, 1]) # 4-dimensional spinor\n\n# Using individual arguments also works\nvector_alt = Irrep(so6, 1, 0, 0)\nnothing # hide\n\nYou can find all irreps up to a given dimension:\n\nirreps_up_to_dim(so6, 10)  # All SO(6) irreps with dimension ≤ 10","category":"section"},{"location":"guide/representations/#Properties","page":"Representations","title":"Properties","text":"","category":"section"},{"location":"guide/representations/#Dimension","page":"Representations","title":"Dimension","text":"[dimension(vector), dimension(spinor_plus), dimension(spinor_minus)]  # [6, 4, 4]","category":"section"},{"location":"guide/representations/#Quadratic-Casimir","page":"Representations","title":"Quadratic Casimir","text":"quadratic_casimir(vector)  # 5/4","category":"section"},{"location":"guide/representations/#Dynkin-Index","page":"Representations","title":"Dynkin Index","text":"The Dynkin index is the trace normalization:\n\n[dynkin_index(vector), dynkin_index(spinor_plus)]  # [1, 1/2]","category":"section"},{"location":"guide/representations/#Congruency-Class","page":"Representations","title":"Congruency Class","text":"The congruency class specifies how a representation acts on the center of the group:\n\n# SO(8) triality: three distinct 8-dimensional irreps\nso8 = D_series(4)\n[congruency_class(Irrep(so8, 1, 0, 0, 0)).value,  # vector: (0, 1)\n congruency_class(Irrep(so8, 0, 0, 1, 0)).value,  # spinor: (1, 1)\n congruency_class(Irrep(so8, 0, 0, 0, 1)).value]  # conjugate spinor: (1, 0)","category":"section"},{"location":"guide/representations/#Conjugation","page":"Representations","title":"Conjugation","text":"[is_self_conjugate(vector), conjugate(spinor_plus) == spinor_minus]  # [true, true]","category":"section"},{"location":"guide/representations/#Dimension-Label","page":"Representations","title":"Dimension Label","text":"The dimension label provides a compact notation that distinguishes representations with the same dimension:\n\n# SU(4) has three dimension-20 representations\nsu4 = A_series(3)\n[dimension_label(Irrep(su4, 0, 1, 1)),  # \"20\"\n dimension_label(Irrep(su4, 1, 1, 0)),  # \"20b\"\n dimension_label(Irrep(su4, 0, 2, 0))]  # \"20′\"","category":"section"},{"location":"guide/representations/#Special-Representations","page":"Representations","title":"Special Representations","text":"# Adjoint representation\nadj = adjoint_irrep(so6)\n[dimension(adj), is_trivial(Irrep(so6, [0, 0, 0]))]  # [15, true]","category":"section"},{"location":"guide/representations/#Representation-Tables","page":"Representations","title":"Representation Tables","text":"You can generate comprehensive tables of representations:\n\nusing Kiwi\n\n# SU(3) table\nprintln(\"SU(3) Representations (dimension ≤ 15)\\n\")\nsu3 = A_series(2)\nirreps = sort(irreps_up_to_dim(su3, 15), by=r->dimension(r))\n\nprintln(\"┌──────────────┬─────────────────┬──────────────┬──────────────┬──────────┐\")\nprintln(\"│ Dim Label    │ Dynkin Labels   │ C₂           │ Dynkin Index │ Cong. Cl │\")\nprintln(\"├──────────────┼─────────────────┼──────────────┼──────────────┼──────────┤\")\nfor rep in irreps\n    labels = dynkin_labels(rep)\n    dim_label = dimension_label(rep)\n    cas = round(quadratic_casimir(rep), digits=3)\n    dyn_idx = dynkin_index(rep)\n    cc = congruency_class(rep).value\n    \n    println(\"│ \", rpad(dim_label, 12), \" │ \",\n            rpad(\"[$(join(labels, \",\"))]\", 15), \" │ \",\n            rpad(string(cas), 12), \" │ \",\n            rpad(string(dyn_idx), 12), \" │ \",\n            rpad(string(cc), 8), \" │\")\nend\nprintln(\"└──────────────┴─────────────────┴──────────────┴──────────────┴──────────┘\")\nnothing # hide\n\n# SO(8) table showing triality\nprintln(\"\\nSO(8) Representations (dimension ≤ 60)\\n\")\nso8 = D_series(4)\nirreps = sort(irreps_up_to_dim(so8, 60), by=r->dimension(r))\n\nprintln(\"┌──────────────┬─────────────────┬──────────────┬──────────────┬──────────┐\")\nprintln(\"│ Dim Label    │ Dynkin Labels   │ C₂           │ Dynkin Index │ Cong. Cl │\")\nprintln(\"├──────────────┼─────────────────┼──────────────┼──────────────┼──────────┤\")\nfor rep in irreps\n    labels = dynkin_labels(rep)\n    dim_label = dimension_label(rep)\n    cas = round(quadratic_casimir(rep), digits=3)\n    dyn_idx = dynkin_index(rep)\n    cc = congruency_class(rep).value\n    cc_str = cc === nothing ? \"trivial\" : string(cc)\n    \n    println(\"│ \", rpad(dim_label, 12), \" │ \",\n            rpad(\"[$(join(labels, \",\"))]\", 15), \" │ \",\n            rpad(string(cas), 12), \" │ \",\n            rpad(string(dyn_idx), 12), \" │ \",\n            rpad(cc_str, 8), \" │\")\nend\nprintln(\"└──────────────┴─────────────────┴──────────────┴──────────────┴──────────┘\")\nnothing # hide","category":"section"},{"location":"guide/representations/#See-Also","page":"Representations","title":"See Also","text":"Tensor Products: Decomposing tensor products\nCharacters: Weight decompositions\nAPI Reference: Representations","category":"section"},{"location":"guide/weyl_groups/#Weyl-Groups","page":"Weyl Groups","title":"Weyl Groups","text":"The Weyl group is the symmetry group of the root system, generated by reflections through hyperplanes perpendicular to simple roots.","category":"section"},{"location":"guide/weyl_groups/#Basic-Operations","page":"Weyl Groups","title":"Basic Operations","text":"Let's use SO(9) = B₄ as an example:\n\nusing Kiwi\n\nso9 = SO(9)\nvector = Irrep(so9, [1, 0, 0, 0])\nnothing # hide","category":"section"},{"location":"guide/weyl_groups/#Simple-Roots","page":"Weyl Groups","title":"Simple Roots","text":"roots = simple_roots(so9)\nlength(roots)  # 4","category":"section"},{"location":"guide/weyl_groups/#Weyl-Reflections","page":"Weyl Groups","title":"Weyl Reflections","text":"Reflect a weight through a hyperplane perpendicular to a simple root:\n\nweight = Weight(so9, [2, 1, 0, 0])\nreflected = weyl_reflection(weight, roots[1])","category":"section"},{"location":"guide/weyl_groups/#Dominant-Weights","page":"Weyl Groups","title":"Dominant Weights","text":"A weight is dominant if all its Dynkin labels are non-negative:\n\nw1 = Weight(so9, [2, 1, 0, 0])\nw2 = Weight(so9, [-1, 2, 0, 0])\n[is_dominant(w1), is_dominant(w2)]  # [true, false]\n\nEvery weight can be reflected to a unique dominant weight:\n\ndominant, sign = reflect_to_dominant(w2)","category":"section"},{"location":"guide/weyl_groups/#Weyl-Group-Order","page":"Weyl Groups","title":"Weyl Group Order","text":"# SO(9) = B₄ has Weyl group of order 2⁴ · 4! = 384\nweyl_group_order(so9)","category":"section"},{"location":"guide/weyl_groups/#Weyl-Orbits","page":"Weyl Groups","title":"Weyl Orbits","text":"Get all Weyl group images of a weight:\n\nweight = Weight(so9, [1, 0, 0, 0])\norbit = weyl_orbit(weight)\n\n# Dictionary with keys 1 (positive sign) and -1 (negative sign)\n[length(orbit[1]), length(orbit[-1])]","category":"section"},{"location":"guide/weyl_groups/#See-Also","page":"Weyl Groups","title":"See Also","text":"Characters: Uses weight systems\nTensor Products: Uses Weyl reflections\nAPI Reference: Weyl Groups","category":"section"},{"location":"#Kiwi.jl","page":"Home","title":"Kiwi.jl","text":"A Julia package for Lie algebra representation theory\n\nKiwi.jl provides efficient tools for working with Lie algebras and their representations.","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using Kiwi\n\n# Create SU(3) and fundamental representations\nfund = Irrep(SU(3), 1, 0)\nanti_fund = conjugate(fund)\n\n# Compute tensor products\nprintln(\"3 ⊗ 3= \", fund ⊗ anti_fund)\n\n# Check if trivial representation appears\ntrivial = Irrep(SU(3), 0, 0)\nresult = fund ⊗ anti_fund\nprintln(\"Multiplicity of trivial: \", result[trivial])\n\n# Compute characters\nchar = character(fund)\nprintln(\"Dimension: \", sum(wm.multiplicity for wm in char))","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"Kiwi\")","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\n    \"guide/getting_started.md\",\n    \"guide/lie_algebras.md\",\n    \"guide/representations.md\",\n    \"guide/characters.md\",\n    \"guide/tensor_products.md\",\n    \"guide/weyl_groups.md\",\n]\nDepth = 2","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"api/weyl/#Weyl-Groups-API","page":"Weyl Groups","title":"Weyl Groups API","text":"","category":"section"},{"location":"api/weyl/#Weyl-Reflections","page":"Weyl Groups","title":"Weyl Reflections","text":"","category":"section"},{"location":"api/weyl/#Dominant-Weights","page":"Weyl Groups","title":"Dominant Weights","text":"","category":"section"},{"location":"api/weyl/#Weyl-Orbits","page":"Weyl Groups","title":"Weyl Orbits","text":"","category":"section"},{"location":"api/weyl/#Kiwi.simple_reflection-Tuple{Weight, Int64}","page":"Weyl Groups","title":"Kiwi.simple_reflection","text":"simple_reflection(weight::Weight, i::Int)\n\nReflect a weight across the i-th simple root.\n\nThis is a convenience function that applies the Weyl reflection corresponding to the i-th simple root α_i.\n\nArguments\n\nweight: The weight to reflect\ni: Index of the simple root (1-indexed)\n\nReturns\n\nA new Weight object representing the reflected weight.\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.weyl_reflection-Tuple{Weight, Weight}","page":"Weyl Groups","title":"Kiwi.weyl_reflection","text":"weyl_reflection(weight::Weight, root::Weight)\n\nReflect a weight across the hyperplane perpendicular to a root.\n\nThe Weyl reflection sα is given by:     sα(λ) = λ - 2(λ, α)/(α, α) · α\n\nwhere (·,·) is the inner product in the weight space.\n\nArguments\n\nweight: The weight to reflect\nroot: The root defining the reflection hyperplane (typically a simple root)\n\nReturns\n\nA new Weight object representing the reflected weight.\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [1, 0])\nα = simple_roots(g)[1]\nλ_reflected = weyl_reflection(λ, α)\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.weyl_reflection-Tuple{Weight, WeylWord}","page":"Weyl Groups","title":"Kiwi.weyl_reflection","text":"weyl_reflection(weight::Weight, w::WeylWord)\n\nApply a sequence of simple Weyl reflections to a weight.\n\nThe word is applied right-to-left (i.e., rightmost reflection is applied first). For a WeylWord with word [i₁, i₂, ..., iₖ], this computes:     s{i₁} · s{i₂} · ... · s_{iₖ}(weight)\n\nArguments\n\nweight: The weight to reflect\nw: The Weyl word specifying the sequence of reflections\n\nReturns\n\nA new Weight object after applying all reflections.\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [1, 0])\nw = WeylWord(g, [1, 2, 1])\nλ_reflected = weyl_reflection(λ, w)\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.is_dominant-Tuple{Weight}","page":"Weyl Groups","title":"Kiwi.is_dominant","text":"is_dominant(weight::Weight)\n\nCheck if a weight is dominant (i.e., lies in the dominant Weyl chamber).\n\nA weight λ is dominant if (λ, αi) ≥ 0 for all simple roots αi, or equivalently, if all Dynkin labels are non-negative.\n\nIn the fundamental weight basis with coordinates [c₁, c₂, ..., cₙ], the weight is λ = Σ cᵢ ωᵢ where ωᵢ are fundamental weights. The Dynkin labels are mᵢ = 2(λ, αᵢ)/(αᵢ, αᵢ).\n\nArguments\n\nweight: The weight to check\n\nReturns\n\ntrue if the weight is dominant, false otherwise.\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [1, 0])  # Fundamental weight, dominant\n@assert is_dominant(λ)\n\nμ = Weight(g, [-1, 2])  # Not dominant\n@assert !is_dominant(μ)\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.reflect_to_dominant-Tuple{Weight}","page":"Weyl Groups","title":"Kiwi.reflect_to_dominant","text":"reflect_to_dominant(weight::Weight; max_reflections::Int=1000)\n\nReflect a weight into the dominant Weyl chamber using Weyl reflections.\n\nUses a greedy algorithm: repeatedly reflects across simple roots for which (λ, α_i) < 0 until the weight becomes dominant or the maximum number of reflections is reached.\n\nArguments\n\nweight: The weight to reflect into the dominant chamber\nmax_reflections: Maximum number of reflections to prevent infinite loops (default: 1000)\n\nReturns\n\nA tuple (dominant_weight, sign) where:\n\ndominant_weight is the weight in the dominant chamber\nsign is +1 or -1 depending on the parity of reflections (det of Weyl group element)\n\nThrows\n\nErrorException if the weight cannot be made dominant within max_reflections steps\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [-1, 2])\nλ_dom, sign = reflect_to_dominant(λ)\n@assert is_dominant(λ_dom)\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.weyl_group_order-Tuple{LieAlgebra}","page":"Weyl Groups","title":"Kiwi.weyl_group_order","text":"weyl_group_order(g::LieAlgebra)\n\nCompute the order of the Weyl group for a Lie algebra.\n\nFormula\n\nA_n: (n+1)!\nB_n: 2^n · n!\nC_n: 2^n · n!\nD_n: 2^(n-1) · n!\nE_6: 51840\nE_7: 2903040\nE_8: 696729600\nF_4: 1152\nG_2: 12\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.weyl_orbit-Tuple{Weight}","page":"Weyl Groups","title":"Kiwi.weyl_orbit","text":"weyl_orbit(weight::Weight; max_size::Int=10000)\n\nCompute the Weyl orbit of a weight (all weights obtained by Weyl reflections).\n\nThe Weyl orbit consists of all distinct weights that can be obtained from the given weight by applying Weyl group elements, along with their signs (determinant of the Weyl group element).\n\nArguments\n\nweight: The starting weight\nmax_size: Maximum size of the orbit to compute (safety limit, default: 10000)\n\nReturns\n\nA dictionary with keys 1 and -1, where each value is a vector of Weight objects with the corresponding sign (parity of reflections).\n\nWarning\n\nFor high-rank algebras and non-special weights, the Weyl orbit can be very large!\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [1, 0])\norbit = weyl_orbit(λ)\n# orbit[1] contains weights with even parity\n# orbit[-1] contains weights with odd parity\n\n\n\n\n\n","category":"method"}]
}
