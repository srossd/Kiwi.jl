var documenterSearchIndex = {"docs":
[{"location":"api/tensor_products/#Tensor-Products-API","page":"Tensor Products","title":"Tensor Products API","text":"","category":"section"},{"location":"api/tensor_products/#Computing-Tensor-Products","page":"Tensor Products","title":"Computing Tensor Products","text":"","category":"section"},{"location":"api/tensor_products/#Unicode-Operator","page":"Tensor Products","title":"Unicode Operator","text":"rep1 ⊗ rep2  # Same as tensor_product(rep1, rep2)\n\nType \\otimes<TAB> in Julia REPL to get ⊗.","category":"section"},{"location":"api/tensor_products/#Kiwi.tensor_product-Tuple{Irrep, Irrep}","page":"Tensor Products","title":"Kiwi.tensor_product","text":"tensor_product(rep1::Irrep, rep2::Irrep)\n\nCompute the tensor product of two irreducible representations using Klimyk's formula.\n\nKlimyk's formula (also known as the Racah-Speiser algorithm) states that:\n\nrep1 ⊗ rep2 = Σ_μ Σ_{w ∈ W} sign(w) · [w(λ₁ + μ)]\n\nwhere:\n\nλ₁ is the highest weight of rep1 (we choose rep1 to be the smaller-dimensional one)\nThe first sum is over all weights μ in the character of rep2\nW is the Weyl group\n[w(λ₁ + μ)] means: reflect w(λ₁ + μ) to the dominant chamber and interpret as an irrep\nsign(w) is the determinant of the Weyl group element w\n\nThe formula automatically handles the necessary cancellations, and only dominant  weights contribute to the final result.\n\nReferences\n\nKlimyk, \"Decomposition of the direct product of irreducible representations\" (1968)\nRacah, \"Group Theory and Spectroscopy\" (1965)\n\nExample\n\ng = A_series(2)\nfund1 = Irrep(g, 1, 0)\nfund2 = Irrep(g, 0, 1)\nresult = tensor_product(fund1, fund2)\n\n\n\n\n\n","category":"method"},{"location":"api/tensor_products/#Kiwi.tensor_product-Tuple{Irrep, Rep}","page":"Tensor Products","title":"Kiwi.tensor_product","text":"tensor_product(rep1::Irrep, rep2::Rep)\ntensor_product(rep1::Rep, rep2::Irrep)\n\nTensor product between irreducible and reducible representations.\n\n\n\n\n\n","category":"method"},{"location":"api/tensor_products/#Kiwi.tensor_product-Tuple{Rep, Rep}","page":"Tensor Products","title":"Kiwi.tensor_product","text":"tensor_product(rep1::Rep, rep2::Rep)\n\nCompute the tensor product of two (possibly reducible) representations.\n\nUses bilinearity: (⊕ᵢ nᵢRᵢ) ⊗ (⊕ⱼ mⱼSⱼ) = ⊕ᵢⱼ (nᵢmⱼ)(Rᵢ ⊗ Sⱼ)\n\n\n\n\n\n","category":"method"},{"location":"guide/tensor_products/#Tensor-Products","page":"Tensor Products","title":"Tensor Products","text":"Compute the decomposition of tensor products of representations into irreducible components using the ⊗ operator.","category":"section"},{"location":"guide/tensor_products/#Basic-Examples","page":"Tensor Products","title":"Basic Examples","text":"Let's use SU(3) to see how tensor products work:\n\nusing Kiwi\n\n# SU(3) = A_2\nsu3 = SU(3)\n\n# Define the fundamental representations\nfund = Irrep(su3, [1, 0])       # 3\nanti_fund = Irrep(su3, [0, 1])  # 3̄\nadj = Irrep(su3, [1, 1])        # 8\nnothing # hide","category":"section"},{"location":"guide/tensor_products/#Fundamental-Fundamental","page":"Tensor Products","title":"Fundamental × Fundamental","text":"# 3 ⊗ 3 = 3̄ ⊕ 6\nresult = fund ⊗ fund\nprintln(\"[1,0] ⊗ [1,0] = \", result)\nprintln(\"Dimension of result: \", dimension(result))","category":"section"},{"location":"guide/tensor_products/#Adjoint-Adjoint","page":"Tensor Products","title":"Adjoint × Adjoint","text":"# 8 ⊗ 8 = 1 ⊕ 8 ⊕ 8 ⊕ 10 ⊕ 10̄ ⊕ 27\nresult = adj ⊗ adj\nprintln(\"[1,1] ⊗ [1,1] = \", result)\nprintln(\"Dimension of result: \", dimension(result))","category":"section"},{"location":"guide/tensor_products/#Accessing-Components","page":"Tensor Products","title":"Accessing Components","text":"# Get multiplicity of a specific irrep in 3 ⊗ 3̄\nresult = fund ⊗ anti_fund\ntrivial = Irrep(su3, [0, 0])\nresult[trivial]  # 1","category":"section"},{"location":"guide/tensor_products/#See-Also","page":"Tensor Products","title":"See Also","text":"API Reference: Tensor Products","category":"section"},{"location":"api/algebras/#Lie-Algebras-API","page":"Lie Algebras","title":"Lie Algebras API","text":"","category":"section"},{"location":"api/algebras/#Creating-Algebras","page":"Lie Algebras","title":"Creating Algebras","text":"","category":"section"},{"location":"api/algebras/#Algebra-Properties","page":"Lie Algebras","title":"Algebra Properties","text":"","category":"section"},{"location":"api/algebras/#Root-System","page":"Lie Algebras","title":"Root System","text":"","category":"section"},{"location":"api/algebras/#Kiwi.A_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.A_series","text":"A_series(n::Int)\n\nConstruct the A_n Lie algebra (su(n+1)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.B_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.B_series","text":"B_series(n::Int)\n\nConstruct the B_n Lie algebra (so(2n+1)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.C_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.C_series","text":"C_series(n::Int)\n\nConstruct the C_n Lie algebra (sp(2n)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.D_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.D_series","text":"D_series(n::Int)\n\nConstruct the D_n Lie algebra (so(2n)).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.E_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.E_series","text":"E_series(n::Int)\n\nConstruct the E_n Lie algebra (n = 6, 7, or 8).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.F_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.F_series","text":"F_series(n::Int)\n\nConstruct the F_4 Lie algebra (n must be 4).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.G_series-Tuple{Int64}","page":"Lie Algebras","title":"Kiwi.G_series","text":"G_series(n::Int)\n\nConstruct the G_2 Lie algebra (n must be 2).\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.cartan_matrix-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.cartan_matrix","text":"cartan_matrix(g::LieAlgebra)\n\nReturn the Cartan matrix for the given Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.dual_coxeter_number-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.dual_coxeter_number","text":"dual_coxeter_number(g::LieAlgebra)\n\nCompute the dual Coxeter number hⱽ of the Lie algebra. This is defined as the Dynkin index of the adjoint representation.\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.lie_rank-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.lie_rank","text":"lie_rank(g::LieAlgebra)\n\nReturn the rank of the Lie algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/algebras/#Kiwi.simple_roots-Tuple{LieAlgebra}","page":"Lie Algebras","title":"Kiwi.simple_roots","text":"simple_roots(g::LieAlgebra)\n\nReturn the simple roots of the Lie algebra in the fundamental weight basis. The simple root αi in fundamental weight coordinates: αi = Σj Cij ω_j (rows of C)\n\n\n\n\n\n","category":"method"},{"location":"guide/characters/#Characters","page":"Characters","title":"Characters","text":"Characters provide the complete weight decomposition of a representation, giving all weights with their multiplicities.","category":"section"},{"location":"guide/characters/#Computing-Characters","page":"Characters","title":"Computing Characters","text":"Let's start with some SU(3) examples:\n\nusing Kiwi\n\nsu3 = SU(3)\nfund = Irrep(su3, [1, 0])      # 3\nanti_fund = Irrep(su3, [0, 1])  # 3̄\nadj = Irrep(su3, [1, 1])       # 8\n\n# Compute characters\nchar_fund = character(fund)\nchar_anti = character(anti_fund)\nchar_adj = character(adj)\n\nCheck dimensions and number of distinct weights:\n\n[dimension(char_fund), length(char_fund)]  # [3, 3]\n\n[dimension(char_anti), length(char_anti)]  # [3, 3]\n\n[dimension(char_adj), length(char_adj)]    # [8, 7]","category":"section"},{"location":"guide/characters/#Accessing-Weight-Multiplicities","page":"Characters","title":"Accessing Weight Multiplicities","text":"# Query a specific weight in the adjoint\nw = Weight(su3, [0, 0])\nchar_adj[w]  # 2 (the zero weight has multiplicity 2 in the adjoint)","category":"section"},{"location":"guide/characters/#Lazy-Characters","page":"Characters","title":"Lazy Characters","text":"For large representations, LazyCharacter computes multiplicities on demand without computing the full character:\n\nusing Kiwi\n\n# Large E₆ representation: [1,0,1,1,0,1] has dimension 138,881,925\ne6 = E_series(6)\nrep = Irrep(e6, [2, 1, 0, 0, 0, 1])\n\nprintln(\"Dimension: \", dimension(rep))\n\n# Create lazy character (instant)\nlazy_char = LazyCharacter(rep)\n\nQuery specific weights quickly:\n\n# Highest weight\n@time lazy_char[highest_weight(rep)]\nlength(lazy_char.computed)\n@time lazy_char[Weight(e6, [-1, -2, 1, 1, -2, 1])]\nlength(lazy_char.computed)\n\nFor comparison, computing the full character takes much longer:\n\n@time char_full = character(rep);\n\nThe lazy character only computes what you need, making it efficient for querying specific multiplicities in large representations.","category":"section"},{"location":"guide/characters/#See-Also","page":"Characters","title":"See Also","text":"API Reference: Characters","category":"section"},{"location":"guide/lie_algebras/#Lie-Algebras","page":"Lie Algebras","title":"Lie Algebras","text":"Kiwi.jl provides comprehensive support for all simple Lie algebras.","category":"section"},{"location":"guide/lie_algebras/#Creating-Lie-Algebras","page":"Lie Algebras","title":"Creating Lie Algebras","text":"","category":"section"},{"location":"guide/lie_algebras/#Classical-Algebras","page":"Lie Algebras","title":"Classical Algebras","text":"You can create Lie algebras using either the series notation or standard mathematical notation:\n\nusing Kiwi # hide\n\n# A series: SU(n+1)\nsu3 = A_series(2)    # SU(3)\nsu5 = A_series(4)    # SU(5)\n\n# Or use the SU helper\nsu3_alt = SU(3)      # Same as A_series(2)\n\n# B series: SO(2n+1)\nso5 = B_series(2)    # SO(5)\nso9 = B_series(4)    # SO(9)\n\n# Or use the SO helper\nso5_alt = SO(5)      # Same as B_series(2)\n\n# C series: Sp(2n)\nsp4 = C_series(2)    # Sp(4)\nsp6 = C_series(3)    # Sp(6)\n\n# Or use the Sp helper\nsp4_alt = Sp(4)      # Same as C_series(2)\n\n# D series: SO(2n)\nso8 = D_series(4)    # SO(8)\nso10 = D_series(5)   # SO(10)\n\n# Or use the SO helper\nso8_alt = SO(8)      # Same as D_series(4)\nnothing # hide\n\nThe helper functions SU(n), SO(n), and Sp(n) provide more intuitive notation:\n\nSU(n) creates su(n), which is A_{n-1} (requires n ≥ 2)\nSO(n) creates so(n), which is Bk for n=2k+1 or Dk for n=2k (requires n ≥ 3)\nSp(n) creates sp(n), which is C_{n/2} (requires even n ≥ 2)","category":"section"},{"location":"guide/lie_algebras/#Exceptional-Algebras","page":"Lie Algebras","title":"Exceptional Algebras","text":"e6 = E_series(6)\ne7 = E_series(7)\ne8 = E_series(8)\nf4 = F_series(4)\ng2 = G_series(2)\nnothing # hide","category":"section"},{"location":"guide/lie_algebras/#Algebra-Properties","page":"Lie Algebras","title":"Algebra Properties","text":"","category":"section"},{"location":"guide/lie_algebras/#Basic-Properties","page":"Lie Algebras","title":"Basic Properties","text":"println(\"SU(3) properties:\")\nprintln(\"--------------\")\nprintln(\"Dimension: \", dimension(su3))\nprintln(\"Rank: \", lie_rank(su3))\nprintln(\"Dual Coxeter number: \", dual_coxeter_number(su3))\nprintln(\"Cartan matrix:\\n\", cartan_matrix(su3))","category":"section"},{"location":"guide/lie_algebras/#Root-System","page":"Lie Algebras","title":"Root System","text":"Access the simple roots:\n\nprintln(\"Simple roots of SU(3): \", simple_roots(su3))\n\nThe Weyl vector ρ (half-sum of positive roots):\n\nprintln(\"Weyl vector of SU(3): \", weyl_vector(su3))","category":"section"},{"location":"guide/lie_algebras/#See-Also","page":"Lie Algebras","title":"See Also","text":"API Reference: Lie Algebras: Complete function documentation","category":"section"},{"location":"guide/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Install Kiwi.jl using Julia's package manager:\n\nusing Pkg\nPkg.add(\"Kiwi\")","category":"section"},{"location":"guide/getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"using Kiwi\n\n# Create a Lie algebra\nSU3 = SU(3)\n\n# Get properties of representations\nfund = Irrep(SU3, 1, 0)\nprintln(\"Properties of fundamental representation:\")\nprintln(\"\\tDimension: \", dimension(fund))\nprintln(\"\\tCasimir:   \", quadratic_casimir(fund))\nprintln(\"\\tIndex:     \", dynkin_index(fund))","category":"section"},{"location":"guide/getting_started/#Key-Concepts","page":"Getting Started","title":"Key Concepts","text":"","category":"section"},{"location":"guide/getting_started/#Lie-Algebras","page":"Getting Started","title":"Lie Algebras","text":"Kiwi.jl supports all classical and exceptional simple Lie algebras:\n\nA series: SU(n+1)\nB series: SO(2n+1)\nC series: Sp(2n)\nD series: SO(2n)\nE series: E₆, E₇, E₈\nF series: F₄\nG series: G₂","category":"section"},{"location":"guide/getting_started/#Irreducible-Representations","page":"Getting Started","title":"Irreducible Representations","text":"Representations are specified by their highest weight in terms of Dynkin labels:\n\n# SU(3) representations\nanti_fund = Irrep(SU(3), 0, 1)   # 3̄\nadjoint = Irrep(SU(3), 1, 1)     # 8\n\n# SO(5) representations\nvector = Irrep(SO(5), 1, 0)      # 5\nspinor = Irrep(SO(5), 0, 1)      # 4\n\nprint([rep => dimension(rep) for rep in [fund, anti_fund, adjoint, vector, spinor]])","category":"section"},{"location":"guide/getting_started/#Characters","page":"Getting Started","title":"Characters","text":"The character of a representation is the complete list of weights with their multiplicities:\n\nprint(character(fund))","category":"section"},{"location":"guide/getting_started/#Tensor-Products","page":"Getting Started","title":"Tensor Products","text":"Compute tensor product decompositions using the ⊗ operator:\n\nprint(fund ⊗ anti_fund)","category":"section"},{"location":"guide/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Lie Algebras\nRepresentations\nTensor Products\nCharacters\nWeyl groups","category":"section"},{"location":"api/characters/#Characters-API","page":"Characters","title":"Characters API","text":"","category":"section"},{"location":"api/characters/#Computing-Characters","page":"Characters","title":"Computing Characters","text":"","category":"section"},{"location":"api/characters/#Kiwi.character-Tuple{Irrep}","page":"Characters","title":"Kiwi.character","text":"character(rep::Irrep)\n\nCompute the complete character of an irreducible representation. Returns a Character object containing all weights with their multiplicities.\n\nUses Freudenthal's multiplicity formula, which recursively computes the multiplicity of each weight μ from the multiplicities of weights μ + kα for positive roots α.\n\nAlgorithm\n\nStarting from the highest weight λ (with multiplicity 1), we work our way down by subtracting positive roots. For each new weight μ, Freudenthal's formula gives:\n\n2(λ+ρ, μ) m(μ) = Σ_{α>0} Σ_{k≥1} 2(μ+kα, α) m(μ+kα)\n\nwhere the sum is over all positive roots α and all k such that μ+kα is a weight.\n\nReturns\n\nA Character object with a dictionary mapping weights to multiplicities.\n\nReferences\n\nHumphreys, \"Introduction to Lie Algebras and Representation Theory\" (1972), §22.3\nFulton & Harris, \"Representation Theory\" (1991), §15.2\n\n\n\n\n\n","category":"method"},{"location":"api/characters/#Kiwi.dimension-Tuple{Character}","page":"Characters","title":"Kiwi.dimension","text":"dimension(char::Character)\n\nCompute the dimension of a character (total number of weights counting multiplicities).\n\n\n\n\n\n","category":"method"},{"location":"api/characters/#Kiwi.dimension-Tuple{LazyCharacter}","page":"Characters","title":"Kiwi.dimension","text":"dimension(char::LazyCharacter)\n\nCompute the dimension of a lazy character using its irrep.\n\n\n\n\n\n","category":"method"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Kiwi.LieAlgebra","page":"Types","title":"Kiwi.LieAlgebra","text":"LieAlgebra\n\nRepresents a simple Lie algebra by its type and rank. Supported types: A, B, C, D (classical) and E, F, G (exceptional).\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Irrep","page":"Types","title":"Kiwi.Irrep","text":"Irrep\n\nRepresents an irreducible representation of a Lie algebra by its highest weight. The highest weight is specified by Dynkin labels.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Rep","page":"Types","title":"Kiwi.Rep","text":"Rep\n\nRepresents a (possibly reducible) representation as a linear combination of irreps. Stored as a dictionary mapping irreps to their multiplicities.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Weight","page":"Types","title":"Kiwi.Weight","text":"Weight vector in the weight space of a Lie algebra. Weights are represented as linear combinations of fundamental weights: w = Σ ci ωi.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.AbstractCharacter","page":"Types","title":"Kiwi.AbstractCharacter","text":"AbstractCharacter\n\nAbstract base type for character representations. Subtypes must implement Base.getindex(char, weight) to return multiplicities.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.Character","page":"Types","title":"Kiwi.Character","text":"Character <: AbstractCharacter\n\nRepresents a fully computed character with all weights and multiplicities precomputed.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.LazyCharacter","page":"Types","title":"Kiwi.LazyCharacter","text":"LazyCharacter <: AbstractCharacter\n\nRepresents a lazily-evaluated character that computes weight multiplicities on demand. Only computes multiplicities for weights that are explicitly queried.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#Kiwi.WeightMultiplicity","page":"Types","title":"Kiwi.WeightMultiplicity","text":"WeightMultiplicity\n\nA weight with its multiplicity in a representation.\n\n\n\n\n\n","category":"type"},{"location":"api/representations/#Representations-API","page":"Representations","title":"Representations API","text":"","category":"section"},{"location":"api/representations/#Creating-Representations","page":"Representations","title":"Creating Representations","text":"","category":"section"},{"location":"api/representations/#Representation-Properties","page":"Representations","title":"Representation Properties","text":"","category":"section"},{"location":"api/representations/#Kiwi.adjoint_irrep-Tuple{LieAlgebra}","page":"Representations","title":"Kiwi.adjoint_irrep","text":"adjoint_irrep(g::LieAlgebra)\n\nReturn the adjoint representation of the Lie algebra as an Irrep.\n\nThe adjoint representation corresponds to the Lie algebra acting on itself via the commutator. For any simple Lie algebra, the adjoint has highest weight equal to the highest root, which can be expressed in Dynkin labels.\n\nDynkin labels for adjoint representations\n\nA_n: 1, 0, ..., 0, 1\nB_n: 0, 1, 0, ..., 0\nC_n: 2, 0, ..., 0\nD_n: 0, 1, 0, ..., 0\nE_6: 0, 0, 0, 0, 0, 1\nE_7: 1, 0, 0, 0, 0, 0, 0\nE_8: 0, 0, 0, 0, 0, 0, 1, 0\nF_4: 1, 0, 0, 0\nG_2: 0, 1\n\nReferences\n\nFulton & Harris, \"Representation Theory\" (1991), Section 21.1\nHumphreys, \"Introduction to Lie Algebras and Representation Theory\" (1972)\nOnline database: http://www.liegroups.org/\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.conjugate-Tuple{Irrep}","page":"Representations","title":"Kiwi.conjugate","text":"conjugate(rep::Irrep)\n\nReturn the conjugate (dual) representation.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.dynkin_labels-Tuple{Irrep}","page":"Representations","title":"Kiwi.dynkin_labels","text":"dynkin_labels(rep::Irrep)\n\nGet the Dynkin labels of an irreducible representation.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.is_self_conjugate-Tuple{Irrep}","page":"Representations","title":"Kiwi.is_self_conjugate","text":"is_self_conjugate(rep::Irrep)\n\nCheck if the representation is self-conjugate.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.is_trivial-Tuple{Irrep}","page":"Representations","title":"Kiwi.is_trivial","text":"is_trivial(rep::Irrep)\n\nCheck if the representation is the trivial representation.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.dimension-Tuple{Irrep}","page":"Representations","title":"Kiwi.dimension","text":"dimension(rep::Irrep)\n\nCompute the dimension of an irreducible representation using Weyl's dimension formula: dim(λ) = ∏_{α > 0} (λ+ρ, α) / (ρ, α) where the product is over all positive roots α, and ρ is the Weyl vector.\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.dynkin_index-Tuple{Irrep}","page":"Representations","title":"Kiwi.dynkin_index","text":"dynkin_index(rep::Irrep)\n\nCompute the Dynkin index (also known as the second index) of the representation. For the adjoint representation, this equals 2h^∨ (twice the dual Coxeter number).\n\n\n\n\n\n","category":"method"},{"location":"api/representations/#Kiwi.quadratic_casimir-Tuple{Irrep}","page":"Representations","title":"Kiwi.quadratic_casimir","text":"quadratic_casimir(rep::Irrep)\n\nCompute the quadratic Casimir invariant C_2(rep). The eigenvalue is given by (λ, λ + 2ρ) / 2 where ρ is the Weyl vector. This normalization is standard in physics literature.\n\n\n\n\n\n","category":"method"},{"location":"guide/representations/#Representations","page":"Representations","title":"Representations","text":"Representations in Kiwi.jl are specified by their Dynkin labels, which correspond to the highest weight in the fundamental weight basis.","category":"section"},{"location":"guide/representations/#Defining-Representations","page":"Representations","title":"Defining Representations","text":"Let's use SO(6) as an example:\n\nusing Kiwi\n\n# SO(6) = D_3\nso6 = SO(6)\n\n# Define representations by Dynkin labels\nvector = Irrep(so6, [1, 0, 0])      # 6-dimensional vector\nspinor_plus = Irrep(so6, [0, 1, 0])  # 4-dimensional spinor\nspinor_minus = Irrep(so6, [0, 0, 1]) # 4-dimensional spinor\n\n# Using individual arguments also works\nvector_alt = Irrep(so6, 1, 0, 0)\nnothing # hide","category":"section"},{"location":"guide/representations/#Properties","page":"Representations","title":"Properties","text":"","category":"section"},{"location":"guide/representations/#Dimension","page":"Representations","title":"Dimension","text":"[dimension(vector), dimension(spinor_plus), dimension(spinor_minus)]  # [6, 4, 4]","category":"section"},{"location":"guide/representations/#Quadratic-Casimir","page":"Representations","title":"Quadratic Casimir","text":"quadratic_casimir(vector)  # 5/4","category":"section"},{"location":"guide/representations/#Dynkin-Index","page":"Representations","title":"Dynkin Index","text":"The Dynkin index is the trace normalization:\n\n[dynkin_index(vector), dynkin_index(spinor_plus)]  # [1, 1/2]","category":"section"},{"location":"guide/representations/#Conjugation","page":"Representations","title":"Conjugation","text":"[is_self_conjugate(vector), conjugate(spinor_plus) == spinor_minus]  # [true, true]","category":"section"},{"location":"guide/representations/#Special-Representations","page":"Representations","title":"Special Representations","text":"# Adjoint representation\nadj = adjoint_irrep(so6)\n[dimension(adj), is_trivial(Irrep(so6, [0, 0, 0]))]  # [15, true]","category":"section"},{"location":"guide/representations/#See-Also","page":"Representations","title":"See Also","text":"Tensor Products: Decomposing tensor products\nCharacters: Weight decompositions\nAPI Reference: Representations","category":"section"},{"location":"guide/weyl_groups/#Weyl-Groups","page":"Weyl Groups","title":"Weyl Groups","text":"The Weyl group is the symmetry group of the root system, generated by reflections through hyperplanes perpendicular to simple roots.","category":"section"},{"location":"guide/weyl_groups/#Basic-Operations","page":"Weyl Groups","title":"Basic Operations","text":"Let's use SO(9) = B₄ as an example:\n\nusing Kiwi\n\nso9 = SO(9)\nvector = Irrep(so9, [1, 0, 0, 0])\nnothing # hide","category":"section"},{"location":"guide/weyl_groups/#Simple-Roots","page":"Weyl Groups","title":"Simple Roots","text":"roots = simple_roots(so9)\nlength(roots)  # 4","category":"section"},{"location":"guide/weyl_groups/#Weyl-Reflections","page":"Weyl Groups","title":"Weyl Reflections","text":"Reflect a weight through a hyperplane perpendicular to a simple root:\n\nweight = Weight(so9, [2, 1, 0, 0])\nreflected = weyl_reflection(weight, roots[1])","category":"section"},{"location":"guide/weyl_groups/#Dominant-Weights","page":"Weyl Groups","title":"Dominant Weights","text":"A weight is dominant if all its Dynkin labels are non-negative:\n\nw1 = Weight(so9, [2, 1, 0, 0])\nw2 = Weight(so9, [-1, 2, 0, 0])\n[is_dominant(w1), is_dominant(w2)]  # [true, false]\n\nEvery weight can be reflected to a unique dominant weight:\n\ndominant, sign = reflect_to_dominant(w2)","category":"section"},{"location":"guide/weyl_groups/#Weyl-Group-Order","page":"Weyl Groups","title":"Weyl Group Order","text":"# SO(9) = B₄ has Weyl group of order 2⁴ · 4! = 384\nweyl_group_order(so9)","category":"section"},{"location":"guide/weyl_groups/#Weyl-Orbits","page":"Weyl Groups","title":"Weyl Orbits","text":"Get all Weyl group images of a weight:\n\nweight = Weight(so9, [1, 0, 0, 0])\norbit = weyl_orbit(weight)\n\n# Dictionary with keys 1 (positive sign) and -1 (negative sign)\n[length(orbit[1]), length(orbit[-1])]","category":"section"},{"location":"guide/weyl_groups/#See-Also","page":"Weyl Groups","title":"See Also","text":"Characters: Uses weight systems\nTensor Products: Uses Weyl reflections\nAPI Reference: Weyl Groups","category":"section"},{"location":"#Kiwi.jl","page":"Home","title":"Kiwi.jl","text":"A Julia package for Lie algebra representation theory\n\nKiwi.jl provides efficient tools for working with Lie algebras and their representations.","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using Kiwi\n\n# Create SU(3) and fundamental representations\nfund = Irrep(SU(3), 1, 0)\nanti_fund = conjugate(fund)\n\n# Compute tensor products\nprintln(\"3 ⊗ 3= \", fund ⊗ anti_fund)\n\n# Check if trivial representation appears\ntrivial = Irrep(SU(3), 0, 0)\nresult = fund ⊗ anti_fund\nprintln(\"Multiplicity of trivial: \", result[trivial])\n\n# Compute characters\nchar = character(fund)\nprintln(\"Dimension: \", sum(wm.multiplicity for wm in char))","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"Kiwi\")","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\n    \"guide/getting_started.md\",\n    \"guide/lie_algebras.md\",\n    \"guide/representations.md\",\n    \"guide/characters.md\",\n    \"guide/tensor_products.md\",\n    \"guide/weyl_groups.md\",\n]\nDepth = 2","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"api/weyl/#Weyl-Groups-API","page":"Weyl Groups","title":"Weyl Groups API","text":"","category":"section"},{"location":"api/weyl/#Weyl-Reflections","page":"Weyl Groups","title":"Weyl Reflections","text":"","category":"section"},{"location":"api/weyl/#Dominant-Weights","page":"Weyl Groups","title":"Dominant Weights","text":"","category":"section"},{"location":"api/weyl/#Weyl-Orbits","page":"Weyl Groups","title":"Weyl Orbits","text":"","category":"section"},{"location":"api/weyl/#Kiwi.simple_reflection-Tuple{Weight, Int64}","page":"Weyl Groups","title":"Kiwi.simple_reflection","text":"simple_reflection(weight::Weight, i::Int)\n\nReflect a weight across the i-th simple root.\n\nThis is a convenience function that applies the Weyl reflection corresponding to the i-th simple root α_i.\n\nArguments\n\nweight: The weight to reflect\ni: Index of the simple root (1-indexed)\n\nReturns\n\nA new Weight object representing the reflected weight.\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.weyl_reflection-Tuple{Weight, Weight}","page":"Weyl Groups","title":"Kiwi.weyl_reflection","text":"weyl_reflection(weight::Weight, root::Weight)\n\nReflect a weight across the hyperplane perpendicular to a root.\n\nThe Weyl reflection sα is given by:     sα(λ) = λ - 2(λ, α)/(α, α) · α\n\nwhere (·,·) is the inner product in the weight space.\n\nArguments\n\nweight: The weight to reflect\nroot: The root defining the reflection hyperplane (typically a simple root)\n\nReturns\n\nA new Weight object representing the reflected weight.\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [1, 0])\nα = simple_roots(g)[1]\nλ_reflected = weyl_reflection(λ, α)\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.is_dominant-Tuple{Weight}","page":"Weyl Groups","title":"Kiwi.is_dominant","text":"is_dominant(weight::Weight)\n\nCheck if a weight is dominant (i.e., lies in the dominant Weyl chamber).\n\nA weight λ is dominant if (λ, αi) ≥ 0 for all simple roots αi, or equivalently, if all Dynkin labels are non-negative.\n\nIn the fundamental weight basis with coordinates [c₁, c₂, ..., cₙ], the weight is λ = Σ cᵢ ωᵢ where ωᵢ are fundamental weights. The Dynkin labels are mᵢ = 2(λ, αᵢ)/(αᵢ, αᵢ).\n\nArguments\n\nweight: The weight to check\n\nReturns\n\ntrue if the weight is dominant, false otherwise.\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [1, 0])  # Fundamental weight, dominant\n@assert is_dominant(λ)\n\nμ = Weight(g, [-1, 2])  # Not dominant\n@assert !is_dominant(μ)\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.reflect_to_dominant-Tuple{Weight}","page":"Weyl Groups","title":"Kiwi.reflect_to_dominant","text":"reflect_to_dominant(weight::Weight; max_reflections::Int=1000)\n\nReflect a weight into the dominant Weyl chamber using Weyl reflections.\n\nUses a greedy algorithm: repeatedly reflects across simple roots for which (λ, α_i) < 0 until the weight becomes dominant or the maximum number of reflections is reached.\n\nArguments\n\nweight: The weight to reflect into the dominant chamber\nmax_reflections: Maximum number of reflections to prevent infinite loops (default: 1000)\n\nReturns\n\nA tuple (dominant_weight, sign) where:\n\ndominant_weight is the weight in the dominant chamber\nsign is +1 or -1 depending on the parity of reflections (det of Weyl group element)\n\nThrows\n\nErrorException if the weight cannot be made dominant within max_reflections steps\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [-1, 2])\nλ_dom, sign = reflect_to_dominant(λ)\n@assert is_dominant(λ_dom)\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.weyl_group_order-Tuple{LieAlgebra}","page":"Weyl Groups","title":"Kiwi.weyl_group_order","text":"weyl_group_order(g::LieAlgebra)\n\nCompute the order of the Weyl group for a Lie algebra.\n\nFormula\n\nA_n: (n+1)!\nB_n: 2^n · n!\nC_n: 2^n · n!\nD_n: 2^(n-1) · n!\nE_6: 51840\nE_7: 2903040\nE_8: 696729600\nF_4: 1152\nG_2: 12\n\n\n\n\n\n","category":"method"},{"location":"api/weyl/#Kiwi.weyl_orbit-Tuple{Weight}","page":"Weyl Groups","title":"Kiwi.weyl_orbit","text":"weyl_orbit(weight::Weight; max_size::Int=10000)\n\nCompute the Weyl orbit of a weight (all weights obtained by Weyl reflections).\n\nThe Weyl orbit consists of all distinct weights that can be obtained from the given weight by applying Weyl group elements, along with their signs (determinant of the Weyl group element).\n\nArguments\n\nweight: The starting weight\nmax_size: Maximum size of the orbit to compute (safety limit, default: 10000)\n\nReturns\n\nA dictionary with keys 1 and -1, where each value is a vector of Weight objects with the corresponding sign (parity of reflections).\n\nWarning\n\nFor high-rank algebras and non-special weights, the Weyl orbit can be very large!\n\nExample\n\ng = A_series(2)\nλ = Weight(g, [1, 0])\norbit = weyl_orbit(λ)\n# orbit[1] contains weights with even parity\n# orbit[-1] contains weights with odd parity\n\n\n\n\n\n","category":"method"}]
}
