"""
Weyl group operations for Lie algebras.

The Weyl group is generated by reflections across the hyperplanes perpendicular
to the simple roots. These reflections act on the weight space and are crucial
for understanding the structure of representations.
"""

"""
    WeylWord

Represents a sequence of simple Weyl reflections as a word in the Weyl group.

A Weyl word is stored as a vector of integers, where each integer i represents
the simple reflection s_i corresponding to the i-th simple root.

# Fields
- `algebra::LieAlgebra`: The Lie algebra
- `word::Vector{Int}`: The sequence of simple reflection indices

# Example
```julia
g = A_series(2)
w = WeylWord(g, [1, 2, 1])  # s_1 · s_2 · s_1 (rightmost applied first)
```
"""
struct WeylWord
    algebra::LieAlgebra
    word::Vector{Int}
    
    function WeylWord(algebra::LieAlgebra, word::Vector{Int})
        # Validate that all indices are in valid range
        n = lie_rank(algebra)
        if any(i < 1 || i > n for i in word)
            error("All reflection indices must be between 1 and $n")
        end
        new(algebra, word)
    end
end

# Convenient constructor with varargs
WeylWord(algebra::LieAlgebra, indices::Int...) = WeylWord(algebra, collect(indices))

# Display
function Base.show(io::IO, w::WeylWord)
    if isempty(w.word)
        print(io, "WeylWord(identity)")
    else
        print(io, "WeylWord([$(join(w.word, ", "))])")
    end
end

# Equality
Base.:(==)(w1::WeylWord, w2::WeylWord) = w1.algebra == w2.algebra && w1.word == w2.word

# Length
Base.length(w::WeylWord) = length(w.word)

"""
    weyl_reflection(weight::Weight, root::Weight)

Reflect a weight across the hyperplane perpendicular to a root.

The Weyl reflection s_α is given by:
    s_α(λ) = λ - 2(λ, α)/(α, α) · α

where (·,·) is the inner product in the weight space.

# Arguments
- `weight`: The weight to reflect
- `root`: The root defining the reflection hyperplane (typically a simple root)

# Returns
A new `Weight` object representing the reflected weight.

# Example
```julia
g = A_series(2)
λ = Weight(g, [1, 0])
α = simple_roots(g)[1]
λ_reflected = weyl_reflection(λ, α)
```
"""
function weyl_reflection(weight::Weight, root::Weight)
    @assert weight.algebra == root.algebra "Weight and root must be from the same algebra"
    
    # Compute 2(λ, α)/(α, α)
    numerator = 2 * inner_product(weight, root)
    denominator = inner_product(root, root)
    coeff = numerator / denominator
    
    # Reflect: s_α(λ) = λ - coeff · α
    new_coords = weight.coordinates .- coeff .* root.coordinates
    
    return Weight(weight.algebra, new_coords)
end

"""
    simple_reflection(weight::Weight, i::Int)

Reflect a weight across the i-th simple root.

This is a convenience function that applies the Weyl reflection corresponding
to the i-th simple root α_i.

# Arguments
- `weight`: The weight to reflect
- `i`: Index of the simple root (1-indexed)

# Returns
A new `Weight` object representing the reflected weight.
"""
function simple_reflection(weight::Weight, i::Int)
    g = weight.algebra
    roots = simple_roots(g)
    
    if i < 1 || i > length(roots)
        error("Simple root index $i out of range (1 to $(length(roots)))")
    end
    
    return weyl_reflection(weight, roots[i])
end

"""
    weyl_reflection(weight::Weight, w::WeylWord)

Apply a sequence of simple Weyl reflections to a weight.

The word is applied right-to-left (i.e., rightmost reflection is applied first).
For a WeylWord with word [i₁, i₂, ..., iₖ], this computes:
    s_{i₁} · s_{i₂} · ... · s_{iₖ}(weight)

# Arguments
- `weight`: The weight to reflect
- `w`: The Weyl word specifying the sequence of reflections

# Returns
A new `Weight` object after applying all reflections.

# Example
```julia
g = A_series(2)
λ = Weight(g, [1, 0])
w = WeylWord(g, [1, 2, 1])
λ_reflected = weyl_reflection(λ, w)
```
"""
function weyl_reflection(weight::Weight, w::WeylWord)
    @assert weight.algebra == w.algebra "Weight and WeylWord must be from the same algebra"
    
    result = weight
    # Apply reflections from right to left
    for i in reverse(w.word)
        result = simple_reflection(result, i)
    end
    
    return result
end

"""
    longest_weyl_word(algebra::LieAlgebra)

Compute the longest element w₀ of the Weyl group.

The longest element is the unique element that sends all positive roots to negative roots.
It is returned as a WeylWord.

The algorithm starts with a weight with all coordinates -1 (in the anti-dominant chamber)
and reflects it to the dominant chamber using simple reflections, recording the sequence.

# Arguments
- `algebra`: The Lie algebra

# Returns
A `WeylWord` representing the longest element.

# Example
```julia
g = A_series(2)
w0 = longest_weyl_word(g)
# For A_2, this might be [1, 2, 1] (one of several equivalent reduced words)
```
"""
function longest_weyl_word(algebra::LieAlgebra)
    n = lie_rank(algebra)
    
    # Start with weight [-1, -1, ..., -1] in fundamental weight basis
    weight = Weight(algebra, fill(-1, n))
    result = Int[]
    
    # Reflect until all coordinates are non-negative
    iterations = 0
    
    while !is_dominant(weight)
        # Find first index where weight has negative inner product with simple root
        roots = simple_roots(algebra)
        idx = findfirst(i -> inner_product(weight, roots[i]) < 0, 1:n)
        
        if idx === nothing
            break
        end
        
        # Apply reflection
        weight = simple_reflection(weight, idx)
        
        # Prepend to result (since we're building the word backwards)
        pushfirst!(result, idx)
        
        iterations += 1
    end
    
    return WeylWord(algebra, result)
end

"""
    is_dominant(weight::Weight)

Check if a weight is dominant (i.e., lies in the dominant Weyl chamber).

A weight λ is dominant if (λ, α_i) ≥ 0 for all simple roots α_i,
or equivalently, if all Dynkin labels are non-negative.

In the fundamental weight basis with coordinates [c₁, c₂, ..., cₙ],
the weight is λ = Σ cᵢ ωᵢ where ωᵢ are fundamental weights.
The Dynkin labels are mᵢ = 2(λ, αᵢ)/(αᵢ, αᵢ).

# Arguments
- `weight`: The weight to check

# Returns
`true` if the weight is dominant, `false` otherwise.

# Example
```julia
g = A_series(2)
λ = Weight(g, [1, 0])  # Fundamental weight, dominant
@assert is_dominant(λ)

μ = Weight(g, [-1, 2])  # Not dominant
@assert !is_dominant(μ)
```
"""
function is_dominant(weight::Weight)
    g = weight.algebra
    simple = simple_roots(g)
    
    # Check if (λ, α_i) ≥ 0 for all simple roots α_i
    for α in simple
        if inner_product(weight, α) < 0
            return false
        end
    end
    
    return true
end

"""
    reflect_to_dominant(weight::Weight; max_reflections::Int=1000)

Reflect a weight into the dominant Weyl chamber using Weyl reflections.

Uses a greedy algorithm: repeatedly reflects across simple roots for which
(λ, α_i) < 0 until the weight becomes dominant or the maximum number of
reflections is reached.

# Arguments
- `weight`: The weight to reflect into the dominant chamber
- `max_reflections`: Maximum number of reflections to prevent infinite loops (default: 1000)

# Returns
A tuple `(dominant_weight, sign)` where:
- `dominant_weight` is the weight in the dominant chamber
- `sign` is +1 or -1 depending on the parity of reflections (det of Weyl group element)

# Throws
- `ErrorException` if the weight cannot be made dominant within `max_reflections` steps

# Example
```julia
g = A_series(2)
λ = Weight(g, [-1, 2])
λ_dom, sign = reflect_to_dominant(λ)
@assert is_dominant(λ_dom)
```
"""
function reflect_to_dominant(weight::Weight; max_reflections::Int=1000)
    g = weight.algebra
    simple = simple_roots(g)
    
    current_weight = weight
    sign = 1
    reflections = 0
    
    while !is_dominant(current_weight)
        if reflections >= max_reflections
            error("Could not make weight dominant within $max_reflections reflections")
        end
        
        # Find a simple root α_i such that (λ, α_i) < 0
        reflected = false
        for (i, α) in enumerate(simple)
            if inner_product(current_weight, α) < 0
                current_weight = weyl_reflection(current_weight, α)
                sign *= -1
                reflections += 1
                reflected = true
                break
            end
        end
        
        if !reflected
            # This shouldn't happen if is_dominant is working correctly
            error("Weight appears non-dominant but no reflection found")
        end
    end
    
    return (current_weight, sign)
end

"""
    weyl_orbit(weight::Weight; max_size::Int=10000)

Compute the Weyl orbit of a weight (all weights obtained by Weyl reflections).

The Weyl orbit consists of all distinct weights that can be obtained from
the given weight by applying Weyl group elements, along with their signs
(determinant of the Weyl group element).

# Arguments
- `weight`: The starting weight
- `max_size`: Maximum size of the orbit to compute (safety limit, default: 10000)

# Returns
A dictionary with keys `1` and `-1`, where each value is a vector of `Weight` objects
with the corresponding sign (parity of reflections).

# Warning
For high-rank algebras and non-special weights, the Weyl orbit can be very large!

# Example
```julia
g = A_series(2)
λ = Weight(g, [1, 0])
orbit = weyl_orbit(λ)
# orbit[1] contains weights with even parity
# orbit[-1] contains weights with odd parity
```
"""
function weyl_orbit(weight::Weight; max_size::Int=10000)
    g = weight.algebra
    simple = simple_roots(g)
    
    # Track weights with their signs
    orbit_data = Dict{Vector{Rational{Int}}, Int}()
    orbit_data[weight.coordinates] = 1  # Starting weight has sign +1
    
    to_process = [(weight, 1)]  # (weight, sign) pairs
    
    while !isempty(to_process)
        if length(orbit_data) >= max_size
            @warn "Weyl orbit computation stopped at max_size=$max_size"
            break
        end
        
        w, current_sign = popfirst!(to_process)
        
        # Apply all simple reflections
        for α in simple
            w_reflected = weyl_reflection(w, α)
            new_sign = -current_sign  # Reflection flips the sign
            
            if !haskey(orbit_data, w_reflected.coordinates)
                orbit_data[w_reflected.coordinates] = new_sign
                push!(to_process, (w_reflected, new_sign))
            end
        end
    end
    
    # Organize by sign
    result = Dict{Int, Vector{Weight}}()
    result[1] = [Weight(g, coords) for (coords, sign) in orbit_data if sign == 1]
    result[-1] = [Weight(g, coords) for (coords, sign) in orbit_data if sign == -1]
    
    return result
end

"""
    stabilizer_size(weight::Weight)

Estimate the size of the stabilizer subgroup for a weight.

The stabilizer is the subgroup of the Weyl group that fixes the weight.
This function estimates it by computing the Weyl orbit size and using
|Orbit| = |W| / |Stabilizer|.

# Note
This requires computing the full Weyl orbit, which can be expensive.
"""
function stabilizer_size(weight::Weight)
    orbit = weyl_orbit(weight)
    orbit_size = length(orbit[1]) + length(orbit[-1])
    weyl_order = weyl_group_order(weight.algebra)
    
    return div(weyl_order, orbit_size)
end

"""
    weyl_group_order(g::LieAlgebra)

Compute the order of the Weyl group for a Lie algebra.

# Formula
- A_n: (n+1)!
- B_n: 2^n · n!
- C_n: 2^n · n!
- D_n: 2^(n-1) · n!
- E_6: 51840
- E_7: 2903040
- E_8: 696729600
- F_4: 1152
- G_2: 12
"""
function weyl_group_order(g::LieAlgebra)
    n = g.rank
    
    if g.series == :A
        return factorial(n + 1)
    elseif g.series == :B || g.series == :C
        return 2^n * factorial(n)
    elseif g.series == :D
        return 2^(n-1) * factorial(n)
    elseif g.series == :E
        if n == 6
            return 51840
        elseif n == 7
            return 2903040
        elseif n == 8
            return 696729600
        end
    elseif g.series == :F && n == 4
        return 1152
    elseif g.series == :G && n == 2
        return 12
    end
    
    error("Unknown Weyl group order for $(g)")
end
