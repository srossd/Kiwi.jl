"""
Weyl group operations for Lie algebras.

The Weyl group is generated by reflections across the hyperplanes perpendicular
to the simple roots. These reflections act on the weight space and are crucial
for understanding the structure of representations.
"""

"""
    weyl_reflection(weight::Weight, root::Weight)

Reflect a weight across the hyperplane perpendicular to a root.

The Weyl reflection s_α is given by:
    s_α(λ) = λ - 2(λ, α)/(α, α) · α

where (·,·) is the inner product in the weight space.

# Arguments
- `weight`: The weight to reflect
- `root`: The root defining the reflection hyperplane (typically a simple root)

# Returns
A new `Weight` object representing the reflected weight.

# Example
```julia
g = A_series(2)
λ = Weight(g, [1, 0])
α = simple_roots(g)[1]
λ_reflected = weyl_reflection(λ, α)
```
"""
function weyl_reflection(weight::Weight, root::Weight)
    @assert weight.algebra == root.algebra "Weight and root must be from the same algebra"
    
    # Compute 2(λ, α)/(α, α)
    numerator = 2 * inner_product(weight, root)
    denominator = inner_product(root, root)
    coeff = numerator / denominator
    
    # Reflect: s_α(λ) = λ - coeff · α
    new_coords = weight.coordinates .- coeff .* root.coordinates
    
    return Weight(weight.algebra, new_coords)
end

"""
    simple_reflection(weight::Weight, i::Int)

Reflect a weight across the i-th simple root.

This is a convenience function that applies the Weyl reflection corresponding
to the i-th simple root α_i.

# Arguments
- `weight`: The weight to reflect
- `i`: Index of the simple root (1-indexed)

# Returns
A new `Weight` object representing the reflected weight.
"""
function simple_reflection(weight::Weight, i::Int)
    g = weight.algebra
    roots = simple_roots(g)
    
    if i < 1 || i > length(roots)
        error("Simple root index $i out of range (1 to $(length(roots)))")
    end
    
    return weyl_reflection(weight, roots[i])
end

"""
    is_dominant(weight::Weight)

Check if a weight is dominant (i.e., lies in the dominant Weyl chamber).

A weight λ is dominant if (λ, α_i) ≥ 0 for all simple roots α_i,
or equivalently, if all Dynkin labels are non-negative.

In the fundamental weight basis with coordinates [c₁, c₂, ..., cₙ],
the weight is λ = Σ cᵢ ωᵢ where ωᵢ are fundamental weights.
The Dynkin labels are mᵢ = 2(λ, αᵢ)/(αᵢ, αᵢ).

# Arguments
- `weight`: The weight to check

# Returns
`true` if the weight is dominant, `false` otherwise.

# Example
```julia
g = A_series(2)
λ = Weight(g, [1, 0])  # Fundamental weight, dominant
@assert is_dominant(λ)

μ = Weight(g, [-1, 2])  # Not dominant
@assert !is_dominant(μ)
```
"""
function is_dominant(weight::Weight)
    g = weight.algebra
    simple = simple_roots(g)
    
    # Check if (λ, α_i) ≥ 0 for all simple roots α_i
    for α in simple
        if inner_product(weight, α) < 0
            return false
        end
    end
    
    return true
end

"""
    reflect_to_dominant(weight::Weight; max_reflections::Int=1000)

Reflect a weight into the dominant Weyl chamber using Weyl reflections.

Uses a greedy algorithm: repeatedly reflects across simple roots for which
(λ, α_i) < 0 until the weight becomes dominant or the maximum number of
reflections is reached.

# Arguments
- `weight`: The weight to reflect into the dominant chamber
- `max_reflections`: Maximum number of reflections to prevent infinite loops (default: 1000)

# Returns
A tuple `(dominant_weight, sign)` where:
- `dominant_weight` is the weight in the dominant chamber
- `sign` is +1 or -1 depending on the parity of reflections (det of Weyl group element)

# Throws
- `ErrorException` if the weight cannot be made dominant within `max_reflections` steps

# Example
```julia
g = A_series(2)
λ = Weight(g, [-1, 2])
λ_dom, sign = reflect_to_dominant(λ)
@assert is_dominant(λ_dom)
```
"""
function reflect_to_dominant(weight::Weight; max_reflections::Int=1000)
    g = weight.algebra
    simple = simple_roots(g)
    
    current_weight = weight
    sign = 1
    reflections = 0
    
    while !is_dominant(current_weight)
        if reflections >= max_reflections
            error("Could not make weight dominant within $max_reflections reflections")
        end
        
        # Find a simple root α_i such that (λ, α_i) < 0
        reflected = false
        for (i, α) in enumerate(simple)
            if inner_product(current_weight, α) < 0
                current_weight = weyl_reflection(current_weight, α)
                sign *= -1
                reflections += 1
                reflected = true
                break
            end
        end
        
        if !reflected
            # This shouldn't happen if is_dominant is working correctly
            error("Weight appears non-dominant but no reflection found")
        end
    end
    
    return (current_weight, sign)
end

"""
    weyl_orbit(weight::Weight; max_size::Int=10000)

Compute the Weyl orbit of a weight (all weights obtained by Weyl reflections).

The Weyl orbit consists of all distinct weights that can be obtained from
the given weight by applying Weyl group elements, along with their signs
(determinant of the Weyl group element).

# Arguments
- `weight`: The starting weight
- `max_size`: Maximum size of the orbit to compute (safety limit, default: 10000)

# Returns
A dictionary with keys `1` and `-1`, where each value is a vector of `Weight` objects
with the corresponding sign (parity of reflections).

# Warning
For high-rank algebras and non-special weights, the Weyl orbit can be very large!

# Example
```julia
g = A_series(2)
λ = Weight(g, [1, 0])
orbit = weyl_orbit(λ)
# orbit[1] contains weights with even parity
# orbit[-1] contains weights with odd parity
```
"""
function weyl_orbit(weight::Weight; max_size::Int=10000)
    g = weight.algebra
    simple = simple_roots(g)
    
    # Track weights with their signs
    orbit_data = Dict{Vector{Rational{Int}}, Int}()
    orbit_data[weight.coordinates] = 1  # Starting weight has sign +1
    
    to_process = [(weight, 1)]  # (weight, sign) pairs
    
    while !isempty(to_process)
        if length(orbit_data) >= max_size
            @warn "Weyl orbit computation stopped at max_size=$max_size"
            break
        end
        
        w, current_sign = popfirst!(to_process)
        
        # Apply all simple reflections
        for α in simple
            w_reflected = weyl_reflection(w, α)
            new_sign = -current_sign  # Reflection flips the sign
            
            if !haskey(orbit_data, w_reflected.coordinates)
                orbit_data[w_reflected.coordinates] = new_sign
                push!(to_process, (w_reflected, new_sign))
            end
        end
    end
    
    # Organize by sign
    result = Dict{Int, Vector{Weight}}()
    result[1] = [Weight(g, coords) for (coords, sign) in orbit_data if sign == 1]
    result[-1] = [Weight(g, coords) for (coords, sign) in orbit_data if sign == -1]
    
    return result
end

"""
    stabilizer_size(weight::Weight)

Estimate the size of the stabilizer subgroup for a weight.

The stabilizer is the subgroup of the Weyl group that fixes the weight.
This function estimates it by computing the Weyl orbit size and using
|Orbit| = |W| / |Stabilizer|.

# Note
This requires computing the full Weyl orbit, which can be expensive.
"""
function stabilizer_size(weight::Weight)
    orbit = weyl_orbit(weight)
    orbit_size = length(orbit[1]) + length(orbit[-1])
    weyl_order = weyl_group_order(weight.algebra)
    
    return div(weyl_order, orbit_size)
end

"""
    weyl_group_order(g::LieAlgebra)

Compute the order of the Weyl group for a Lie algebra.

# Formula
- A_n: (n+1)!
- B_n: 2^n · n!
- C_n: 2^n · n!
- D_n: 2^(n-1) · n!
- E_6: 51840
- E_7: 2903040
- E_8: 696729600
- F_4: 1152
- G_2: 12
"""
function weyl_group_order(g::LieAlgebra)
    n = g.rank
    
    if g.series == :A
        return factorial(n + 1)
    elseif g.series == :B || g.series == :C
        return 2^n * factorial(n)
    elseif g.series == :D
        return 2^(n-1) * factorial(n)
    elseif g.series == :E
        if n == 6
            return 51840
        elseif n == 7
            return 2903040
        elseif n == 8
            return 696729600
        end
    elseif g.series == :F && n == 4
        return 1152
    elseif g.series == :G && n == 2
        return 12
    end
    
    error("Unknown Weyl group order for $(g)")
end
